# Стиль кода (C++)

[English](./code-style-cpp.md) | Русский

## Файлы

Принятые расширения:

- `*.cpp` для файлов исходного кода
- `*.h`/`*.hpp` для заголовочных файлов

Файлы должны сохраняться в кодировке UTF-8 с окончанием строк CRLF и должны заканчиваться одной пустой строкой

Новые комментарии следует писать с использованием английского языка

Для названий новых файлов должен использоваться PascalCase, для существующих ранее должен использоваться тот стиль, который уже был принят в библиотеке или проекте

## Комментарии

- Заголовки файлов не используются в проекте, однако следует при необходимости вставлять описание файла в начале:

  ```cpp
  // Описание файла
  ```

- Допускается сообщение о недоработанной функциональности вида `// TODO: Описание`
- Допускается сообщение о баге вида `// BUG: Описание`
- Соблюдать максимальную длину строки
- Если добавлен костыль или хак, то необходимо сообщить об этом в комментарии вида `// HACK: Описание`

## Инклуды

- Не использовать старые include guards
  - Использовать `#pragma once` вместо них
- Все инклуды должны располагаться до основного кода вверху файла и должны быть сгруппированы в следующем порядке:

  ```cpp
  // Предкомпилируемый хедер
  #include "stdafx.h"

  // Внутреннее API
  #include "xrCore.h"
  ```

- Следует с большой осторожностью сортировать инклуды внутри категорий

## Именование

- Уже существующие ранее названия публичных и защищённых функций, методов и классов следует оставлять как есть для сохранения совместимости API
- Названия параметров функций и методов, локальных переменных и объектов должны начинаться с маленькой буквы по camelCase
- Названия логических переменных должны начинаться с глагола:

  ```cpp
  bool hasChildren;
  bool isEnabled;
  ```

- Названия объектов лямбда-функторов должны заканчиваться постфиксом `Lambda`

  ```cpp
  auto addLambda = [](auto a, auto b)
  {
      return a + b;
  };
  ```

- Названия глобальных объектов должны начинаться с префикса `g_`

  ```cpp
  u32 g_SomeGlobalValue;
  ```

- Названия `private` полей классов и структур должны начинаться со знака `_`, а затем должно быть название с маленькой буквы по camelCase

  ```cpp
  u32 _someValue1;
  u64 _someValue2;
  ```

- Названия интерфейсов должны начинаться с префикса `I`
- Названия новых классов и структур, `public` и `protected` методов должны быть в PascalCase
- Названия параметров шаблонов должны иметь описательные имена, если только однобуквенное имя не говорит само за себя, а описательное имя не добавит ценности
- Следует рассмотреть возможность использования названия `T` в качестве названия параметра шаблона, если используется один параметр
- Следует добавлять к названиям параметров шаблонов префикс `T`

## Стандартная функциональность

- Не следует использовать стандартные библиотеки напрямую
  - Использование стандартных библиотек допустимо внутри платформозависимых блоков условной компиляции по согласованию с командой или сопровождающим проекта
- Следует использовать X-Ray типы, контейнеры и функции вместо стандартных
  - Если данный тип, контейнер или функция отсутствует, необходимо объявить соответствующий алиас:

  ```cpp
  using xr_string_view = std::string_view;
  ```

### Типы

| STD                  | X-Ray        |
|----------------------|--------------|
| `unsigned int`       | `u32`        |
| `unsigned long long` | `u64`        |
| `const char[32]`     | `string32`   |
| `const char[64]`     | `string64`   |
| `const char[128]`    | `string128`  |
| `const wchar_t[32]`  | `wstring32`  |
| `const wchar_t[64]`  | `wstring64`  |
| `const wchar_t[128]` | `wstring128` |

Полное описание типов находится в [этом](../src/xrCore/_types.h) файле

### Контейнеры

| STL                  | X-Ray         |
|----------------------|---------------|
| `std::vector`        | `xr_vector`   |
| `std::unordered_map` | `xr_hash_map` |
| `std::map`           | `xr_map`      |
| `std::string`        | `xr_string`   |
| `std::set`           | `xr_set`      |

Полное описание контейнеров находится в [этом](../src/xrCore/_stl_extensions.h) файле

### Функции

| STD       | X-Ray        |
|-----------|--------------|
| `strlen`  | `xr_strlen`  |
| `strext`  | `xr_strext`  |
| `strcmp`  | `xr_strcmp`  |
| `strcmpi` | `xr_strcmpi` |
| `strcpy`  | `xr_strcpy`  |
| `strcat`  | `xr_strcat`  |
| `sprintf` | `xr_sprintf` |

Полное описание функций находится в [этом](../src/xrCore/_std_extensions.h) файле

## Приведение типов

- Приведения в стиле C разрешены и более предпочтительны, чем `static_cast`
- Использовать `smart_cast` вместо `dynamic_cast` если `smart_cast` доступен

## Платформозависимость

Следует помещать платформозависимый код под блок условной компиляции с указанием одного из допустимых макросов в условии:

- `IXR_WINDOWS`
- `IXR_LINUX`
- `IXR_APPLE_SERIES`
- `IXR_BSD_SERIES`

## Форматирование

- Всегда использовать 4 пробела вместо табуляции
- Всегда использовать фигурные скобки для обозначения условий и циклов
- Фигурные скобки должны быть на новой строке
- Между ключевым словом и условием должен быть 1 пробел
  - В диапазонных выражениях двоеточие должно быть выделено с двух сторон

  ```cpp
  if (...)
  {
      ...
  }

  for (...)
  {
      ...
  }

  while (...)
  {
      ...
  }

  for (auto value : someCollection)
  {
      ...
  }

  for (auto& [id, name] : someMap) // Вместо `for (auto it : someMap)`
  {
      ...
  }
  ```

- Тернарный оператор разрешён на одной линии
  - Разделять по строкам при более сложном условии или результате
- Операторы ветвления должны следовать шаблону
  - При использовании скобок для `case` необходимо проставить скобки для всех остальных `case` блоков

  ```cpp
  switch (condition)
  {
      case 1:
          ...
          // falls through

      case 2:
          ...
          break;

      case 3:
          ...
          return;

      case 4:
      case 5:
          ...
          break;

      default:
          break;
  }
  ```

- Следует выполнять перенос и разбиение по строкам наследуемых классов и интерфейсов

  ```cpp
  class SomeClass :
      public IInterface,
      public BaseClass
  {
      ...
  }
  ```

## Запреты

- Следует группировать свойства, геттеры/сеттеры, методы, конструкторы/деструкторы по модификаторам доступа в указанном порядке
- Следует использовать `using` вместо `typedef` там, где это возможно
- Запрещены для использования: `malloc`, `calloc` и `realloc`. Вместо этого следует использовать `xr_alloc`
- Для выделения памяти используется оператор `new`, для освобождения памяти используется оператор `xr_delete`, который автоматически приводит указатели к `nullptr`
- Запрещены исключения C++ в любой форме
  - Следует избегать использования обработки исключений в стиле C, если это не обсуждено с командой или сопровождающим проекта
- Запрещено использование множественного наследования классов
- Объявление метода как `const` является обязательным, если он не изменяет поля класса
  - Константные переменные не являются обязательными
- Функция должна пытаться принимать параметры по ссылке, а не обрабатывать типы, превышающие машинное слово (8 байт)
- Переопределяемые виртуальные методы должны быть указаны с помощью ключевого слова `override`

  ```cpp
  virtual void SomeFunc() override;
  ```

- Следует использовать `nullptr` вместо `NULL`, а также следует использовать `nullptr` для проверок
- Использование строго типизированных перечислений (`enum class`) должно быть везде, где это возможно
- Запрещено использование анонимных перечислений и структур
- Следует избегать большой вложенности кода
- Следует всегда определять конструктор и деструктор
- Прямое полное включение пространства имён в стиле `using namespace` запрещено
- Следует использовать ключевое слово `final` для классов, которые не имеют наследников
- Следует использовать ключевое слово `auto` только в том случае, если инструмент может однозначно вывести тип из выражения
- Следует использовать ключевое слово `default` там, где это возможно
- Следует использовать ключеове слово `delete` для виртуальных функций
